//! RISC-V RV32I Base Integer Instruction Set
//! 
//! Implements the RISC-V 32-bit base integer instruction set with:
//! - 32 general-purpose registers (x0-x31, where x0 is hardwired to zero)
//! - 32-bit instruction encoding
//! - Standard instruction formats: R, I, S, B, U, J
//! - Little-endian memory addressing
//! - 4-byte aligned instruction fetch

// Type aliases for clarity
pub type Logic8 = u8;      
pub type Logic16 = u16;    
pub type Logic32 = u32;    
pub type Word = u32;       // RISC-V word (32 bits)
pub type Addr = u32;       // Memory address

/// RISC-V Instruction Formats
/// All instructions are 32 bits wide
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum InstructionFormat {
    R,  // Register-register operations
    I,  // Immediate and load operations
    S,  // Store operations
    B,  // Branch operations
    U,  // Upper immediate operations
    J,  // Jump operations
}

/// RISC-V Instruction (32-bit encoded)
#[derive(Debug, Clone, Copy)]
pub struct Instruction {
    pub raw: Word,
}

impl Instruction {
    pub fn new(raw: Word) -> Self {
        Self { raw }
    }

    // Extract opcode (bits 0-6)
    pub fn opcode(&self) -> u8 {
        (self.raw & 0x7F) as u8
    }

    // Extract rd (destination register, bits 7-11)
    pub fn rd(&self) -> u8 {
        ((self.raw >> 7) & 0x1F) as u8
    }

    // Extract funct3 (bits 12-14)
    pub fn funct3(&self) -> u8 {
        ((self.raw >> 12) & 0x07) as u8
    }

    // Extract rs1 (source register 1, bits 15-19)
    pub fn rs1(&self) -> u8 {
        ((self.raw >> 15) & 0x1F) as u8
    }

    // Extract rs2 (source register 2, bits 20-24)
    pub fn rs2(&self) -> u8 {
        ((self.raw >> 20) & 0x1F) as u8
    }

    // Extract funct7 (bits 25-31)
    pub fn funct7(&self) -> u8 {
        ((self.raw >> 25) & 0x7F) as u8
    }

    // I-type immediate (sign-extended)
    pub fn imm_i(&self) -> i32 {
        ((self.raw as i32) >> 20)
    }

    // S-type immediate (sign-extended)
    pub fn imm_s(&self) -> i32 {
        let imm11_5 = (self.raw >> 25) & 0x7F;
        let imm4_0 = (self.raw >> 7) & 0x1F;
        let imm = (imm11_5 << 5) | imm4_0;
        // Sign extend
        ((imm as i32) << 20) >> 20
    }

    // B-type immediate (sign-extended)
    pub fn imm_b(&self) -> i32 {
        let imm12 = (self.raw >> 31) & 0x1;
        let imm10_5 = (self.raw >> 25) & 0x3F;
        let imm4_1 = (self.raw >> 8) & 0x0F;
        let imm11 = (self.raw >> 7) & 0x1;
        let imm = (imm12 << 12) | (imm11 << 11) | (imm10_5 << 5) | (imm4_1 << 1);
        // Sign extend
        ((imm as i32) << 19) >> 19
    }

    // U-type immediate
    pub fn imm_u(&self) -> i32 {
        (self.raw & 0xFFFFF000) as i32
    }

    // J-type immediate (sign-extended)
    pub fn imm_j(&self) -> i32 {
        let imm20 = (self.raw >> 31) & 0x1;
        let imm10_1 = (self.raw >> 21) & 0x3FF;
        let imm11 = (self.raw >> 20) & 0x1;
        let imm19_12 = (self.raw >> 12) & 0xFF;
        let imm = (imm20 << 20) | (imm19_12 << 12) | (imm11 << 11) | (imm10_1 << 1);
        // Sign extend
        ((imm as i32) << 11) >> 11
    }
}

/// RISC-V Opcodes (bits 0-6)
#[repr(u8)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Opcode {
    Load      = 0b0000011,  // I-type: LB, LH, LW, LBU, LHU
    OpImm     = 0b0010011,  // I-type: ADDI, SLTI, SLTIU, XORI, ORI, ANDI, SLLI, SRLI, SRAI
    Auipc     = 0b0010111,  // U-type: AUIPC
    Store     = 0b0100011,  // S-type: SB, SH, SW
    Op        = 0b0110011,  // R-type: ADD, SUB, SLL, SLT, SLTU, XOR, SRL, SRA, OR, AND
    Lui       = 0b0110111,  // U-type: LUI
    Branch    = 0b1100011,  // B-type: BEQ, BNE, BLT, BGE, BLTU, BGEU
    Jalr      = 0b1100111,  // I-type: JALR
    Jal       = 0b1101111,  // J-type: JAL
    System    = 0b1110011,  // I-type: ECALL, EBREAK
}

/// CPU Pipeline States
#[repr(u8)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum PipelineState {
    Fetch = 0,
    Decode = 1,
    Execute = 2,
    Memory = 3,
    WriteBack = 4,
}

/// RISC-V ALU Operations
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum AluOp {
    // Arithmetic
    Add,
    Sub,
    
    // Logical
    And,
    Or,
    Xor,
    
    // Shifts
    Sll,    // Shift left logical
    Srl,    // Shift right logical
    Sra,    // Shift right arithmetic
    
    // Comparisons
    Slt,    // Set less than (signed)
    Sltu,   // Set less than (unsigned)
    
    // Pass-through
    PassA,  // Used for LUI, AUIPC, etc.
    PassB,
}

/// Control signals generated by decoder
#[derive(Debug, Clone, Copy)]
pub struct ControlSignals {
    pub alu_op: AluOp,
    pub alu_src: bool,      // false = rs2, true = immediate
    pub reg_write: bool,    // Write to register file
    pub mem_read: bool,     // Read from memory
    pub mem_write: bool,    // Write to memory
    pub mem_to_reg: bool,   // false = ALU result, true = memory
    pub branch: bool,       // Branch instruction
    pub jump: bool,         // Jump instruction
}

impl ControlSignals {
    pub fn new() -> Self {
        Self {
            alu_op: AluOp::Add,
            alu_src: false,
            reg_write: false,
            mem_read: false,
            mem_write: false,
            mem_to_reg: false,
            branch: false,
            jump: false,
        }
    }
}

/// Branch comparison results
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum BranchCondition {
    Eq,   // Equal
    Ne,   // Not equal
    Lt,   // Less than (signed)
    Ge,   // Greater or equal (signed)
    Ltu,  // Less than (unsigned)
    Geu,  // Greater or equal (unsigned)
}

/// Helper to encode RISC-V instructions
pub struct InstructionEncoder;

impl InstructionEncoder {
    // R-type: funct7 | rs2 | rs1 | funct3 | rd | opcode
    pub fn r_type(opcode: u8, rd: u8, funct3: u8, rs1: u8, rs2: u8, funct7: u8) -> Word {
        ((funct7 as Word) << 25)
            | ((rs2 as Word) << 20)
            | ((rs1 as Word) << 15)
            | ((funct3 as Word) << 12)
            | ((rd as Word) << 7)
            | (opcode as Word)
    }

    // I-type: imm[11:0] | rs1 | funct3 | rd | opcode
    pub fn i_type(opcode: u8, rd: u8, funct3: u8, rs1: u8, imm: i16) -> Word {
        ((imm as u32 & 0xFFF) << 20)
            | ((rs1 as Word) << 15)
            | ((funct3 as Word) << 12)
            | ((rd as Word) << 7)
            | (opcode as Word)
    }

    // S-type: imm[11:5] | rs2 | rs1 | funct3 | imm[4:0] | opcode
    pub fn s_type(opcode: u8, funct3: u8, rs1: u8, rs2: u8, imm: i16) -> Word {
        let imm_u = imm as u32 & 0xFFF;
        ((imm_u & 0xFE0) << 20)
            | ((rs2 as Word) << 20)
            | ((rs1 as Word) << 15)
            | ((funct3 as Word) << 12)
            | ((imm_u & 0x1F) << 7)
            | (opcode as Word)
    }

    // U-type: imm[31:12] | rd | opcode
    pub fn u_type(opcode: u8, rd: u8, imm: i32) -> Word {
        ((imm as Word) & 0xFFFFF000)
            | ((rd as Word) << 7)
            | (opcode as Word)
    }
}


